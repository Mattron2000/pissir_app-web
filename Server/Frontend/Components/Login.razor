@using Frontend.States
@using Shared.DTOs.User
@using Shared.FluentValidators
@using static Frontend.Components.MessageBox

@inject AuthState AuthState
@inject AuthStateNotifier AuthStateNotifier
@inject HttpClient HttpClient

@if (AuthState.User == null)
{
<h3>@Title</h3>

<CascadingValue Value="errorModel">
    <MessageBox OnCloseCallBack="OnCloseMessageBox" />
</CascadingValue>

<EditForm Model="@loginUser" OnSubmit="HandleLoginSubmit">
    <div class="mb-3 max-width-item">
        <label for="email" class="form-label">Email:</label>
        <InputText class="form-control" @bind-Value="loginUser.Email" />
    </div>

    <div class="mb-3 max-width-item">
        <label for="password" class="form-label">Password:</label>
        <InputText class="form-control" type="password"  @bind-Value="loginUser.Password" />
    </div>

    <button type="submit" class="btn btn-primary">Login</button>
</EditForm>
}

@code {
    [Parameter]
    public EventCallback<bool> OnClickCallback { get; set; }
    private MessageBoxModel errorModel = new();
    private UserLoginDTO loginUser = new();
    private readonly string Title = "Login";


    protected override void OnInitialized()
    {
        AuthStateNotifier.Subscribe(StateHasChanged);
        errorModel.Reset();
    }

    public void Dispose()
    {
        AuthStateNotifier.Unsubscribe(StateHasChanged);
    }

    private void OnCloseMessageBox()
    {
    }

    private async void HandleLoginSubmit()
    {
        if (ValidateUserDataInput() == false)
            return;

        HttpResponseMessage response = await HttpClient.PostAsJsonAsync("api/v1/users/login", loginUser);

        if (!response.IsSuccessStatusCode)
        {
            errorModel.Title = (await response.Content.ReadFromJsonAsync<MessageDTO>())?.Message ?? "Unknown error";
            errorModel.Type = MessageType.Warning;
            errorModel.IsVisible = true;
            return;
        }

        AuthState.SetUser(await response.Content.ReadFromJsonAsync<UserEntityDTO>());
        AuthStateNotifier.Notify();

        await OnClickCallback.InvokeAsync(true);
    }

    private bool ValidateUserDataInput()
    {
        var validator = new UserLoginValidator();
        var results = validator.Validate(loginUser);

        var StatusValidation = results.IsValid;
        errorModel.Reasons = results.Errors.Select(e => e.ErrorMessage).ToList();

        if (!StatusValidation)
        {
            errorModel.Title = "Please respect the validator suggestions";
            errorModel.Type = MessageType.Warning;
            errorModel.IsVisible = true;
        }

        return StatusValidation;
    }
}
